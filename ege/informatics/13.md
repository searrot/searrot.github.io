# Задание 13

## №1
### Задача
![](./source/1pz.png)
### Решение
![](./source/1p.png)
### Ответ
4
### Комментарий
`from ipaddress import *`: 
из библиотеки ipaddress импортируем всё, что там есть (по факту, могли бы написать `from ipaddress import ip_network`, так как нам нужна только функция ip_network)  

`net = ip_network('136.36.240.16/255.255.255.248', 0)`: ip_network - это функция, которая вернёт нам объект, в котором хранятся узлы сети  
Первый аргумент функции должен выглядеть так: 'адрес узла или адрес сети/маска'
Значит, мы запишем его так: '136.36.240.16/255.255.255.248'  
Второй аргумент всегда должен быть 0, можно с этим не заморачиваться

`c = 0`: вводим счётчик

`for ip in net:`: так как в нет хранятся узлы сети, то можно перебрать его с помощью цикла for

`if f'{int(ip):032b}'.count('101') == 0: `: разберемся по порядку  
`f'{int(ip):032b}'` - ip можно перевести в числовой вид и привести его к виду двоичного числа длины 32 с помощью специального форматирования, все это делаем в f-строке  
Это нам нужно потому, что ip адреса, адреса сетей и маски, с которыми мы работаем - это двоичные числа длины 32.  
`if f'{int(ip):032b}'.count('101') == 0: `: если в адресе нет 101  
`c += 1`: то прибавляем счётчик

`print(c)`: выводим счётчик

## №8
### Задача
![](./source/8pz.png)
### Решение
![](./source/8p.png)
### Ответ
Программа вывела 214.120.240.0  
Ответ ECFA
### Комментарий
`from ipaddress import *`: импортим всё из библиотеки  
`net = ip_network('214.120.249.18/255.255.240.0', 0)`:  
Из задачи выше: Первый аргумент функции должен выглядеть так: 'адрес узла или адрес сети/маска', поэтому тут `'214.120.249.18/255.255.240.0'` написали по сути 'адрес узла/маска'  
`print(net.network_address)`: у net есть свойство network_address, которое буквально означает адрес сети, который нам как раз и нужен. выводим его и пишем ответ

### Другой вариант решения
![](./source/8p2.png)
`print(f'{214 & 255}.{120 & 255}.{249 & 240}.{18 & 0}')` - это весь код, который нужен для решения.  
Из теории мы с вами знаем, что если применить к соответствующим байтам в адресе узла и маске (т.е. 1 с 1, 2 со 2 и т.д.) поразрядную конъюнкцию (в питоне это операция производится через амперсанд &), то мы получим байты адреса сети  
Вывод получим такой же - 214.120.240.0

## №9
### Задача
![](./source/9pz.png)
### Решение
![](./source/9p.png)
### Ответ
26
### Комментарий
`from ipaddress import *`: импортим всё из библиотеки  
`ip_addr = '163.232.136.60'`
`net_addr = '163.232.136.0'`: задаем переменные с адресом узла и адресом сети  
`for mask in range(31):`: почему мы перебираем маску среди чисел 0...30?  
Раньше мы с вами использовали такой формат: `ip_network('136.36.240.16/255.255.255.248', 0)`, то есть маску писали через 4 числа - 255.255.255.248.  
Давайте вспомним, что маска в двочном виде - это сначала идущие подряд единицы, а потом идущие подряд нули, по типу: 1111111111111111110000000000000  
так вот, в `for mask in range(31):` mask - это число единиц в маске (обычно в маске не используется 31 и 32 единицы, поэтому перебираем среди 0...30)  
теперь, когда мы используем `ip_network(f"{ip_addr}/{mask}", 0)`, ip_addr - это так же адрес из 4 чисел, а mask - это кол-во единиц в маске (то есть какая то реально существующая маска).  
`if ip_network(f"{ip_addr}/{mask}", 0) == ip_network(f"{net_addr}/{mask}", 0):`:  
тут мы проверяем, что сеть, которую мы получили из адреса узла и маски равна сети, которую мы получили из адреса сети и маски.  
Если они равны, то такая маска действительно может быть для данного адреса сети и адреса узла.
`print(mask)`: - тут выводим число единиц в маске, и по условию задачи ищем наибольшее возможное число  